<!-- <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Product Image Editor - Preview</title>
    
    <script src="https://unpkg.com/react@17/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;700&display=swap" rel="stylesheet">

    <style>
        body {
            margin: 0;  
            font-family: 'Poppins', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
                'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
                sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            background-color: #f0f2f5;
            color: #333;
        }

        .App {
            max-width: 900px;
            margin: 20px auto;
            padding: 0 20px 20px;
        }
        
        header {
            text-align: center;
            padding: 20px 0;
            color: #1a237e;
            border-bottom: 1px solid #e0e0e0;
            margin-bottom: 20px;
        }

        header h1 {
            margin: 0;
        }
        
        footer {
            text-align: center;
            margin-top: 40px;
            color: #777;
            font-size: 14px;
        }

        .card {
            background-color: #ffffff;
            border-radius: 16px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.08);
            padding: 25px 30px;
            margin-bottom: 25px;
            text-align: center;
        }
        
        h2 {
           color: #1a237e;
           margin-top: 0;
        }
        
        h3 {
           color: #3f51b5;
        }
        
        h4 {
           margin-top: 25px;
           color: #555;
        }

        .container {
            width: 100%;
        }

        .button {
            background-image: linear-gradient(to right, #4e54c8, #8f94fb);
            color: white;
            border: none;
            padding: 14px 28px;
            border-radius: 10px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 10px;
            font-weight: 500;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
        }

        .button:disabled {
            background-image: none;
            background-color: #b0bec5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .button.secondary {
            background-image: none;
            background-color: #f1f3f4;
            color: #5f6368;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .button.secondary:hover {
            background-color: #e8eaed;
        }
        
        .button.small {
            padding: 10px 20px;
            font-size: 14px;
        }

        .button-group {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 20px;
        }

        .input-field {
            width: calc(100% - 44px);
            padding: 14px 22px;
            margin: 15px 0;
            border: 1px solid #ccc;
            border-radius: 10px;
            font-size: 16px;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
        }

        .input-field:focus {
            outline: none;
            border-color: #3f51b5;
            box-shadow: 0 0 0 3px rgba(63, 81, 181, 0.2);
        }
        
        .file-input-wrapper {
            position: relative;
            display: inline-block;
            overflow: hidden;
            margin-top: 15px;
        }
        .file-input-wrapper .button {
            margin: 0;
        }
        .file-input-wrapper input[type=file] {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            cursor: pointer;
        }

        .image-preview-box {
            margin-top: 20px;
            padding: 15px;
            border: 2px dashed #d1d9e6;
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 200px;
        }

        .image-preview {
            max-width: 100%;
            max-height: 300px;
            border-radius: 8px;
        }
        
        .final-preview {
             border-style: solid;
             border-color: #8f94fb;
        }

        .image-gallery {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
            gap: 20px;
            margin-top: 25px;
        }

        .image-gallery-item {
            border: 4px solid transparent;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            overflow: hidden;
            position: relative;
        }

        .image-gallery-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }

        .image-gallery-item:hover {
            transform: scale(1.05);
            border-color: rgba(143, 148, 251, 0.5);
        }

        .image-gallery-item.selected {
            border-color: #4e54c8;
            box-shadow: 0 0 15px rgba(78, 84, 200, 0.5);
            transform: scale(1.05);
        }
        
        .image-gallery-item .overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0,0,0,0.6);
            color: white;
            text-align: center;
            padding: 8px;
            font-size: 14px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .image-gallery-item:hover .overlay, .image-gallery-item.selected .overlay {
            opacity: 1;
        }


        .color-palette {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
        }

        .color-option {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            cursor: pointer;
            border: 3px solid #fff;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .color-option:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(0,0,0,0.25);
        }
        
        .prompt-form {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            margin-top: 20px;
        }

        .loader {
            border: 8px solid #f3f3f3;
            border-top: 8px solid #4e54c8;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        
        .error-box {
            background-color: #fff0f0;
            border: 1px solid #ffcccc;
        }
        .error-box h2 {
            color: #d32f2f;
        }
        

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        // --- Combined JavaScript for the React App ---

        // --- From utils.js ---
        function hexToRgb(hex) {
            let r = 0, g = 0, b = 0;
            if (hex.length === 4) {
                r = parseInt(hex[1] + hex[1], 16);
                g = parseInt(hex[2] + hex[2], 16);
                b = parseInt(hex[3] + hex[3], 16);
            } else if (hex.length === 7) {
                r = parseInt(hex.substring(1, 3), 16);
                g = parseInt(hex.substring(3, 5), 16);
                b = parseInt(hex.substring(5, 7), 16);
            }
            return [r, g, b];
        }

        function rgbToHex(rgb) {
            return "#" + rgb.map(x => {
                const hex = x.toString(16);
                return hex.length === 1 ? '0' + hex : hex;
            }).join('');
        }
        
        function rgbToHsl(r, g, b) {
            r /= 255; g /= 255; b /= 255;
            let max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
            if (max === min) { h = s = 0; }
            else {
                let d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }
            return [h, s, l];
        }

        function hslToRgb(h, s, l) {
            let r, g, b;
            if (s === 0) { r = g = b = l; }
            else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1 / 6) return p + (q - p) * 6 * t;
                    if (t < 1 / 2) return q;
                    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                    return p;
                };
                let q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                let p = 2 * l - q;
                r = hue2rgb(p, q, h + 1 / 3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1 / 3);
            }
            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }

        function generateShades(baseHexColor, numShades = 5) {
            const rgb = hexToRgb(baseHexColor);
            const hsl = rgbToHsl(rgb[0], rgb[1], rgb[2]);
            const shades = [];
            for (let i = 0; i < numShades; i++) {
                const lightness = 0.2 + (i / (numShades - 1)) * 0.7; // Wider range for more distinct shades
                const newRgb = hslToRgb(hsl[0], hsl[1], lightness);
                shades.push(rgbToHex(newRgb));
            }
            return shades;
        }

        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = () => resolve(reader.result);
                reader.onerror = error => reject(error);
            });
        }

        // --- IMPORTANT: Update this URL to your Cloud Run service URL ---
        const API_BASE_URL = 'https://imagen-ai-723767509826.us-central1.run.app'; 
            
        // --- MODIFIED API function to expect the new response structure ---
        async function processImageRequest(params) {
            console.log("🚀 Calling Cloud Run API with params:", params);
            
            try {
                const response = await fetch(`${API_BASE_URL}/process_image`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(params)
                });

                const result = await response.json();

                if (response.ok) {
                    console.log('✅ Cloud Run API returned:', result);
                    // --- KEY CHANGE IN FRONTEND: Now expecting 'processed_images' as a list of objects ---
                    // The backend sends 'processed_images', not 'processed_images_base64'
                    if (result.processed_images && Array.isArray(result.processed_images)) {
                        // Return the entire list of { base64_image, gcs_url } objects
                        return result.processed_images; 
                    } else {
                        console.error("API response missing 'processed_images' array or it's not an array:", result);
                        throw new Error("Invalid response from API. Please try again or check the backend logs.");
                    }
                } else {
                    const errorDetail = result.detail || result.message || JSON.stringify(result);
                    console.error('API responded with an error:', errorDetail);
                    throw new Error(`API Error: ${errorDetail}`);
                }
            } catch (error) {
                console.error('An error occurred during the API call:', error);
                throw new Error(`Network or processing error: ${error.message || 'Unknown error'}`);
            }
        }

        // --- From App.js ---
        const { useState, useCallback } = React;

        const ImageUploader = ({ onImageUpload }) => (
            <div className="container card">
                <h2>Step 1: Upload Your Product Image</h2>
                <p>Select an image file from your device to begin the editing process.</p>
                <div className="file-input-wrapper">
                    <button className="button">Choose File</button>
                    <input
                        type="file"
                        accept="image/png, image/jpeg, image/webp"
                        onChange={async (e) => {
                            if (e.target.files && e.target.files[0]) {
                                const base64 = await fileToBase64(e.target.files[0]);
                                onImageUpload(base64);
                            }
                        }}
                    />
                </div>
            </div>
        );

        const MainMenu = ({ onChoice, uploadedImage, onReset }) => (
            <div className="container">
                <div className="image-preview-box card">
                    <h3>Your Image</h3>
                    <img src={uploadedImage} alt="Uploaded product" className="image-preview" />
                </div>
                <div className="main-menu-container card">
                    <h2>Step 2: Choose an Action</h2>
                    <div className="button-group">
                        <button className="button" onClick={() => onChoice('changeBg')}>
                            <span role="img" aria-label="palette">🎨</span> Change Background
                        </button>
                        <button className="button" onClick={() => onChoice('generateNew')}>
                            <span role="img" aria-label="sparkles">✨</span> Generate New Images
                        </button>
                        <button className="button secondary" onClick={onReset}>Start Over</button>
                    </div>
                </div>
            </div>
        );

        const BackgroundChanger = ({ onGenerate, onBack }) => {
            const [bgChoice, setBgChoice] = useState(null);
            const [customPrompt, setCustomPrompt] = useState('');
            const colorMap = {
                'Red': '#FF0000', 'Green': '#00FF00', 'Blue': '#0000FF',
                'Yellow': '#FFFF00', 'Purple': '#800080', 'Grey': '#808080'
            };

            const handlePaletteClick = (colorName) => {
                const baseHex = colorMap[colorName];
                const shades = generateShades(baseHex, 5);
                onGenerate({ type: 'palette', shades, hex: baseHex });
            };

            const handleCustomSubmit = (e) => {
                e.preventDefault();
                if (customPrompt.trim()) {
                    onGenerate({ type: 'prompt', prompt: customPrompt });
                } else {
                    alert("Please enter a background description.");
                }
            };

            return (
                <div className="container card">
                    <h2>Change Background Color</h2>
                    <div className="button-group">
                        <button className={`button small ${bgChoice === 'palette' ? '' : 'secondary'}`} onClick={() => setBgChoice('palette')}>From Color Palette</button>
                        <button className={`button small ${bgChoice === 'prompt' ? '' : 'secondary'}`} onClick={() => setBgChoice('prompt')}>With AI Prompt</button>
                    </div>

                    {bgChoice === 'palette' && (
                        <div className="palette-container">
                            <h4>Click a color to generate 5 shades</h4>
                            <div className="color-palette">
                                {Object.keys(colorMap).map(name => (
                                    <div
                                        key={name}
                                        className="color-option"
                                        style={{ backgroundColor: colorMap[name] }}
                                        title={name}
                                        onClick={() => handlePaletteClick(name)}
                                    />
                                ))}
                            </div>
                        </div>
                    )}

                    {bgChoice === 'prompt' && (
                        <form onSubmit={handleCustomSubmit} className="prompt-form">
                            <h4>Describe the background you want</h4>
                            <input
                                type="text"
                                className="input-field"
                                placeholder="e.g., a serene beach at sunset"
                                value={customPrompt}
                                onChange={(e) => setCustomPrompt(e.target.value)}
                            />
                            <button type="submit" className="button">Generate Backgrounds</button>
                        </form>
                    )}
                    <button className="button secondary" onClick={onBack}>Back to Menu</button>
                </div>
            );
        };

        const ProductGenerator = ({ onGenerate, onBack }) => {
            const [prompt, setPrompt] = useState('');

            const handleSubmit = (e) => {
                e.preventDefault();
                if (prompt.trim()) {
                    onGenerate(prompt);
                } else {
                    alert("Please enter a product description.");
                }
            };

            return (
                <div className="container card">
                    <h2>Generate New Product Images</h2>
                    <p>Describe the new product or scene you envision. The AI will generate 5 options.</p>
                    <form onSubmit={handleSubmit} className="prompt-form">
                        <input
                            type="text"
                            className="input-field"
                            placeholder="e.g., a sleek red sports car on a racetrack"
                            value={prompt}
                            onChange={(e) => setPrompt(e.target.value)}
                        />
                        <button type="submit" className="button">Generate 5 Images</button>
                    </form>
                    <button className="button secondary" onClick={onBack}>Back</button>
                </div>
            );
        };

        const ImageGallery = ({ images, onSelect, selectedImage, onConfirm, onReset }) => (
            <div className="container card">
                <h2>Step 3: Choose Your Favorite</h2>
                <p>Select the image you'd like to keep, then click "Confirm Selection".</p>
                <div className="image-gallery">
                    {/* Map through the images array which now contains GCS URLs */}
                    {images.map((imgUrl, index) => ( 
                        <div
                            key={index}
                            className={`image-gallery-item ${selectedImage === imgUrl ? 'selected' : ''}`}
                            onClick={() => onSelect(imgUrl)}
                        >
                            <img src={imgUrl} alt={`Generated result ${index + 1}`} />
                            <div className="overlay">Option {index + 1}</div>
                        </div>
                    ))}
                </div>
                <div className="button-group">
                    <button className="button" onClick={onConfirm} disabled={!selectedImage}>Confirm Selection</button>
                    <button className="button secondary" onClick={onReset}>Back to Menu</button>
                </div>
            </div>
        );

        const FinalImageViewer = ({ image, onSave, onReset }) => {
            const handleSave = () => {
                const defaultName = "final_product_image.png";
                const fileName = prompt("Enter a filename for your image:", defaultName);
                if (fileName) {
                    onSave(image, fileName);
                }
            };
            return (
                <div className="container card">
                    <h2>Step 4: Save Your Image</h2>
                    <div className="image-preview-box final-preview">
                        <img src={image} alt="Final selected product" className="image-preview" />
                    </div>
                    <div className="button-group">
                        <button className="button" onClick={handleSave}>Save to Device</button>
                        <button className="button secondary" onClick={onReset}>Create Another</button>
                    </div>
                </div>
            );
        }

        function App() {
            const [step, setStep] = useState('upload');
            const [uploadedImage, setUploadedImage] = useState(null); // This is still Base64 for the initial upload
            const [generatedImages, setGeneratedImages] = useState([]); // This will now hold GCS URLs
            const [selectedImage, setSelectedImage] = useState(null); // This will hold the selected GCS URL
            const [finalImage, setFinalImage] = useState(null); // This will hold the final GCS URL
            const [isLoading, setIsLoading] = useState(false);
            const [error, setError] = useState(null);

            const handleReset = useCallback(() => {
                setStep('upload');
                setUploadedImage(null);
                setGeneratedImages([]);
                setSelectedImage(null);
                setFinalImage(null);
                setIsLoading(false);
                setError(null);
            }, []);
            
            const handleImageUpload = (base64) => {
                setUploadedImage(base64);
                setStep('menu');
            };

            const handleMenuChoice = (choice) => {
                setStep(choice);
            };

            const runImageProcessing = async (params) => {
                setIsLoading(true);
                setError(null);
                setSelectedImage(null);
                setStep('processing'); // Show loader
                try {
                    // This function now expects and handles the new object structure { base64_image, gcs_url }
                    const results = await processImageRequest(params); 
                    if (!results || results.length === 0) {
                        throw new Error("The AI failed to generate images. Please try a different prompt.");
                    }
                    
                    // --- KEY CHANGE HERE: Extract only the GCS URLs for the gallery ---
                    const gcsUrls = results.map(item => item.gcs_url);
                    setGeneratedImages(gcsUrls); // Update state with generated image URLs
                    setStep('results'); // Show image gallery

                } catch (err) {
                    console.error("Error processing image:", err);
                    setError(err.message || "An unknown error occurred.");
                    setStep('menu'); // Go back to menu if an error occurs
                } finally {
                    setIsLoading(false);
                }
            };

            const handleBgGenerate = async ({ type, shades, prompt, hex }) => {
                if (type === 'palette') {
                    runImageProcessing({
                        uploaded_image_base64: uploadedImage,
                        action: 'background_color',
                        background_color_hex: shades,
                        num_output_images: 5,
                    });
                } else {
                    runImageProcessing({
                        uploaded_image_base64: uploadedImage,
                        action: 'background_generated',
                        background_prompt: prompt,
                        num_output_images: 5,
                    });
                }
            };

            const handleProductGenerate = (prompt) => {
                runImageProcessing({
                    uploaded_image_base64: uploadedImage,
                    action: 'product_edit',
                    product_prompt: prompt,
                    num_output_images: 5,
                });
            };

            const handleConfirmSelection = () => {
                if (selectedImage) {
                    setFinalImage(selectedImage);
                    setStep('final');
                }
            };

            // This function needs to fetch the image data if it's a URL before saving
            const handleSaveImage = (imageUrl, fileName) => {
                fetch(imageUrl)
                    .then(response => response.blob())
                    .then(blob => {
                        const url = window.URL.createObjectURL(blob);
                        const link = document.createElement('a');
                        link.href = url;
                        link.download = fileName;
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        window.URL.revokeObjectURL(url); // Clean up the object URL
                    })
                    .catch(error => {
                        console.error('Error downloading image:', error);
                        alert('Failed to save image. Please try again.');
                    });
            };

            const renderStep = () => {
                if (isLoading || step === 'processing') {
                    return (
                        <div className="container card">
                            <h2>Generating your images...</h2>
                            <p>This may take a moment. The AI is hard at work! ✨</p>
                            <div className="loader"></div>
                        </div>
                    );
                }

                if (error) {
                    return (
                        <div className="container card error-box">
                            <h2>An Error Occurred</h2>
                            <p>{error}</p>
                            <button className="button" onClick={() => { setError(null); setStep('menu'); }}>Try Again</button>
                        </div>
                    )
                }

                switch (step) {
                    case 'upload':
                        return <ImageUploader onImageUpload={handleImageUpload} />;
                    case 'menu':
                        return <MainMenu onChoice={handleMenuChoice} uploadedImage={uploadedImage} onReset={handleReset} />;
                    case 'changeBg':
                        return <BackgroundChanger onGenerate={handleBgGenerate} onBack={() => setStep('menu')} />;
                    case 'generateNew':
                        return <ProductGenerator onGenerate={handleProductGenerate} onBack={() => setStep('menu')} />;
                    case 'results':
                        return <ImageGallery
                            images={generatedImages} // This array now correctly holds GCS URLs
                            selectedImage={selectedImage}
                            onSelect={setSelectedImage}
                            onConfirm={handleConfirmSelection}
                            onReset={() => setStep('menu')}
                        />;
                    case 'final':
                        return <FinalImageViewer image={finalImage} onSave={handleSaveImage} onReset={handleReset} />
                    default:
                        return <ImageUploader onImageUpload={handleImageUpload} />;
                }
            };

            return (
                <div className="App">
                    <header>
                        <h1>AI Product Image Studio</h1>
                    </header>
                    <main>
                        {renderStep()}
                    </main>
                    <footer>
                        <p>Powered by React & AI</p>
                    </footer>
                </div>
            );
        }

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html> -->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Product Image Editor - Preview</title>

    <script src="https://unpkg.com/react@17/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;700&display=swap" rel="stylesheet">

    <style>
        body {
            margin: 0;
            font-family: 'Poppins', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
                'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
                sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            background-color: #f0f2f5;
            color: #333;
        }

        .App {
            max-width: 900px;
            margin: 20px auto;
            padding: 0 20px 20px;
        }

        header {
            text-align: center;
            padding: 20px 0;
            color: #1a237e;
            border-bottom: 1px solid #e0e0e0;
            margin-bottom: 20px;
        }

        header h1 {
            margin: 0;
        }

        footer {
            text-align: center;
            margin-top: 40px;
            color: #777;
            font-size: 14px;
        }

        .card {
            background-color: #ffffff;
            border-radius: 16px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.08);
            padding: 25px 30px;
            margin-bottom: 25px;
            text-align: center;
        }

        h2 {
           color: #1a237e;
           margin-top: 0;
        }

        h3 {
           color: #3f51b5;
        }

        h4 {
           margin-top: 25px;
           color: #555;
        }

        .container {
            width: 100%;
        }

        .button {
            background-image: linear-gradient(to right, #4e54c8, #8f94fb);
            color: white;
            border: none;
            padding: 14px 28px;
            border-radius: 10px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 10px;
            font-weight: 500;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
        }

        .button:disabled {
            background-image: none;
            background-color: #b0bec5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .button.secondary {
            background-image: none;
            background-color: #f1f3f4;
            color: #5f6368;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .button.secondary:hover {
            background-color: #e8eaed;
        }

        .button.small {
            padding: 10px 20px;
            font-size: 14px;
        }

        .button-group {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 20px;
        }

        .input-field {
            width: calc(100% - 44px);
            padding: 14px 22px;
            margin: 15px 0;
            border: 1px solid #ccc;
            border-radius: 10px;
            font-size: 16px;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
        }

        .input-field:focus {
            outline: none;
            border-color: #3f51b5;
            box-shadow: 0 0 0 3px rgba(63, 81, 181, 0.2);
        }

        .file-input-wrapper {
            position: relative;
            display: inline-block;
            overflow: hidden;
            margin-top: 15px;
        }
        .file-input-wrapper .button {
            margin: 0;
        }
        .file-input-wrapper input[type=file] {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            cursor: pointer;
        }

        .image-preview-box {
            margin-top: 20px;
            padding: 15px;
            border: 2px dashed #d1d9e6;
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 200px;
        }

        .image-preview {
            max-width: 100%;
            max-height: 300px;
            border-radius: 8px;
        }

        .final-preview {
             border-style: solid;
             border-color: #8f94fb;
        }

        .image-gallery {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
            gap: 20px;
            margin-top: 25px;
        }

        .image-gallery-item {
            border: 4px solid transparent;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            overflow: hidden;
            position: relative;
        }

        .image-gallery-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }

        .image-gallery-item:hover {
            transform: scale(1.05);
            border-color: rgba(143, 148, 251, 0.5);
        }

        .image-gallery-item.selected {
            border-color: #4e54c8;
            box-shadow: 0 0 15px rgba(78, 84, 200, 0.5);
            transform: scale(1.05);
        }

        .image-gallery-item .overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0,0,0,0.6);
            color: white;
            text-align: center;
            padding: 8px;
            font-size: 14px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .image-gallery-item:hover .overlay, .image-gallery-item.selected .overlay {
            opacity: 1;
        }


        .color-palette {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
        }

        .color-option {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            cursor: pointer;
            border: 3px solid #fff;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .color-option:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(0,0,0,0.25);
        }

        .prompt-form {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            margin-top: 20px;
        }

        .loader {
            border: 8px solid #f3f3f3;
            border-top: 8px solid #4e54c8;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        .error-box {
            background-color: #fff0f0;
            border: 1px solid #ffcccc;
        }
        .error-box h2 {
            color: #d32f2f;
        }


        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        // --- Combined JavaScript for the React App ---

        // --- From utils.js ---
        function hexToRgb(hex) {
            let r = 0, g = 0, b = 0;
            if (hex.length === 4) {
                r = parseInt(hex[1] + hex[1], 16);
                g = parseInt(hex[2] + hex[2], 16);
                b = parseInt(hex[3] + hex[3], 16);
            } else if (hex.length === 7) {
                r = parseInt(hex.substring(1, 3), 16);
                g = parseInt(hex.substring(3, 5), 16);
                b = parseInt(hex.substring(5, 7), 16);
            }
            return [r, g, b];
        }

        function rgbToHex(rgb) {
            return "#" + rgb.map(x => {
                const hex = x.toString(16);
                return hex.length === 1 ? '0' + hex : hex;
            }).join('');
        }

        function rgbToHsl(r, g, b) {
            r /= 255; g /= 255; b /= 255;
            let max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
            if (max === min) { h = s = 0; }
            else {
                let d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }
            return [h, s, l];
        }

        function hslToRgb(h, s, l) {
            let r, g, b;
            if (s === 0) { r = g = b = l; }
            else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1 / 6) return p + (q - p) * 6 * t;
                    if (t < 1 / 2) return q;
                    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                    return p;
                };
                let q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                let p = 2 * l - q;
                r = hue2rgb(p, q, h + 1 / 3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1 / 3);
            }
            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }

        function generateShades(baseHexColor, numShades = 5) {
            const rgb = hexToRgb(baseHexColor);
            const hsl = rgbToHsl(rgb[0], rgb[1], rgb[2]);
            const shades = [];
            for (let i = 0; i < numShades; i++) {
                const lightness = 0.2 + (i / (numShades - 1)) * 0.7; // Wider range for more distinct shades
                const newRgb = hslToRgb(hsl[0], hsl[1], lightness);
                shades.push(rgbToHex(newRgb));
            }
            return shades;
        }

        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = () => resolve(reader.result);
                reader.onerror = error => reject(error);
            });
        }

        // --- IMPORTANT: Update this URL to your Cloud Run service URL ---
        const API_BASE_URL = 'https://imagen-ai-723767509826.us-central1.run.app';

        // --- MODIFIED API function to expect the new response structure ---
        async function processImageRequest(params) {
            console.log("🚀 Calling Cloud Run API with params:", params);

            try {
                const response = await fetch(`${API_BASE_URL}/process_image`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(params)
                });

                const result = await response.json();

                if (response.ok) {
                    console.log('✅ Cloud Run API returned:', result);
                    // --- KEY CHANGE IN FRONTEND: Now expecting 'processed_images' as a list of objects ---
                    // The backend sends 'processed_images', not 'processed_images_base64'
                    if (result.processed_images && Array.isArray(result.processed_images)) {
                        // Return the entire list of { base64_image, gcs_url } objects
                        return result.processed_images;
                    } else {
                        console.error("API response missing 'processed_images' array or it's not an array:", result);
                        throw new Error("Invalid response from API. Please try again or check the backend logs.");
                    }
                } else {
                    const errorDetail = result.detail || result.message || JSON.stringify(result);
                    console.error('API responded with an error:', errorDetail);
                    throw new Error(`API Error: ${errorDetail}`);
                }
            } catch (error) {
                console.error('An error occurred during the API call:', error);
                throw new Error(`Network or processing error: ${error.message || 'Unknown error'}`);
            }
        }

        // --- From App.js ---
        const { useState, useCallback } = React;

        const ImageUploader = ({ onImageUpload }) => (
            <div className="container card">
                <h2>Step 1: Upload Your Product Image</h2>
                <p>Select an image file from your device to begin the editing process.</p>
                <div className="file-input-wrapper">
                    <button className="button">Choose File</button>
                    <input
                        type="file"
                        accept="image/png, image/jpeg, image/webp"
                        onChange={async (e) => {
                            if (e.target.files && e.target.files[0]) {
                                const base64 = await fileToBase64(e.target.files[0]);
                                onImageUpload(base64);
                            }
                        }}
                    />
                </div>
            </div>
        );

        const MainMenu = ({ onChoice, uploadedImage, onReset }) => (
            <div className="container">
                <div className="image-preview-box card">
                    <h3>Your Image</h3>
                    <img src={uploadedImage} alt="Uploaded product" className="image-preview" />
                </div>
                <div className="main-menu-container card">
                    <h2>Step 2: Choose an Action</h2>
                    <div className="button-group">
                        <button className="button" onClick={() => onChoice('changeBg')}>
                            <span role="img" aria-label="palette">🎨</span> Change Background
                        </button>
                        <button className="button" onClick={() => onChoice('generateNew')}>
                            <span role="img" aria-label="sparkles">✨</span> Generate New Images
                        </button>
                        <button className="button secondary" onClick={onReset}>Start Over</button>
                    </div>
                </div>
            </div>
        );

        const BackgroundChanger = ({ onGenerate, onBack }) => {
            const [bgChoice, setBgChoice] = useState(null);
            const [customPrompt, setCustomPrompt] = useState('');
            const colorMap = {
                'Red': '#FF0000', 'Green': '#00FF00', 'Blue': '#0000FF',
                'Yellow': '#FFFF00', 'Purple': '#800080', 'Grey': '#808080'
            };

            const handlePaletteClick = (colorName) => {
                const baseHex = colorMap[colorName];
                const shades = generateShades(baseHex, 5);
                // No prompt for palette generation, pass null or undefined
                onGenerate({ type: 'palette', shades, hex: baseHex, prompt: null });
            };

            const handleCustomSubmit = (e) => {
                e.preventDefault();
                if (customPrompt.trim()) {
                    onGenerate({ type: 'prompt', prompt: customPrompt });
                } else {
                    alert("Please enter a background description.");
                }
            };

            return (
                <div className="container card">
                    <h2>Change Background Color</h2>
                    <div className="button-group">
                        <button className={`button small ${bgChoice === 'palette' ? '' : 'secondary'}`} onClick={() => setBgChoice('palette')}>From Color Palette</button>
                        <button className={`button small ${bgChoice === 'prompt' ? '' : 'secondary'}`} onClick={() => setBgChoice('prompt')}>With AI Prompt</button>
                    </div>

                    {bgChoice === 'palette' && (
                        <div className="palette-container">
                            <h4>Click a color to generate 5 shades</h4>
                            <div className="color-palette">
                                {Object.keys(colorMap).map(name => (
                                    <div
                                        key={name}
                                        className="color-option"
                                        style={{ backgroundColor: colorMap[name] }}
                                        title={name}
                                        onClick={() => handlePaletteClick(name)}
                                    />
                                ))}
                            </div>
                        </div>
                    )}

                    {bgChoice === 'prompt' && (
                        <form onSubmit={handleCustomSubmit} className="prompt-form">
                            <h4>Describe the background you want</h4>
                            <input
                                type="text"
                                className="input-field"
                                placeholder="e.g., a serene beach at sunset"
                                value={customPrompt}
                                onChange={(e) => setCustomPrompt(e.target.value)}
                            />
                            <button type="submit" className="button">Generate Backgrounds</button>
                        </form>
                    )}
                    <button className="button secondary" onClick={onBack}>Back to Menu</button>
                </div>
            );
        };

        const ProductGenerator = ({ onGenerate, onBack }) => {
            const [prompt, setPrompt] = useState('');

            const handleSubmit = (e) => {
                e.preventDefault();
                if (prompt.trim()) {
                    // Pass the prompt value to onGenerate
                    onGenerate(prompt);
                } else {
                    alert("Please enter a product description.");
                }
            };

            return (
                <div className="container card">
                    <h2>Generate New Product Images</h2>
                    <p>Describe the new product or scene you envision. The AI will generate 5 options.</p>
                    <form onSubmit={handleSubmit} className="prompt-form">
                        <input
                            type="text"
                            className="input-field"
                            placeholder="e.g., a sleek red sports car on a racetrack"
                            value={prompt}
                            onChange={(e) => setPrompt(e.target.value)}
                        />
                        <button type="submit" className="button">Generate 5 Images</button>
                    </form>
                    <button className="button secondary" onClick={onBack}>Back</button>
                </div>
            );
        };

        // MODIFIED: ImageGallery now accepts 'inputPrompt' prop
        const ImageGallery = ({ images, onSelect, selectedImage, onConfirm, onReset, inputPrompt }) => (
            <div className="container card">
                <h2>Step 3: Choose Your Favorite</h2>
                <p>Select the image you'd like to keep, then click "Confirm Selection".</p>
                {inputPrompt && <p><strong>Prompt:</strong> {inputPrompt}</p>} {/* Display the prompt here */}
                <div className="image-gallery">
                    {/* Map through the images array which now contains GCS URLs */}
                    {images.map((imgUrl, index) => (
                        <div
                            key={index}
                            className={`image-gallery-item ${selectedImage === imgUrl ? 'selected' : ''}`}
                            onClick={() => onSelect(imgUrl)}
                        >
                            <img src={imgUrl} alt={`Generated result ${index + 1}`} />
                            <div className="overlay">Option {index + 1}</div>
                        </div>
                    ))}
                </div>
                <div className="button-group">
                    <button className="button" onClick={onConfirm} disabled={!selectedImage}>Confirm Selection</button>
                    <button className="button secondary" onClick={onReset}>Back to Menu</button>
                </div>
            </div>
        );

        // MODIFIED: FinalImageViewer to include "Send to Attribute Generation" button
        const FinalImageViewer = ({ image, onSendToAttributeGeneration, onReset }) => {
            const handleSend = () => {
                onSendToAttributeGeneration(image);
            };

            return (
                <div className="container card">
                    <h2>Step 4: Your Final Image</h2>
                    <div className="image-preview-box final-preview">
                        <img src={image} alt="Final selected product" className="image-preview" />
                    </div>
                    <div className="button-group">
                        <button className="button" onClick={handleSend}>Send to Attribute Generation</button>
                        <button className="button secondary" onClick={onReset}>Start Over</button>
                    </div>
                </div>
            );
        }


        function App() {
            const [step, setStep] = useState('upload');
            const [uploadedImage, setUploadedImage] = useState(null); // This is still Base64 for the initial upload
            const [generatedImages, setGeneratedImages] = useState([]); // This will now hold GCS URLs
            const [selectedImage, setSelectedImage] = useState(null); // This will hold the selected GCS URL
            const [finalImage, setFinalImage] = useState(null); // This will hold the final GCS URL
            const [isLoading, setIsLoading] = useState(false);
            const [error, setError] = useState(null);
            const [imageGenerationPrompt, setImageGenerationPrompt] = useState(''); // NEW STATE to store the prompt

            const handleReset = useCallback(() => {
                setStep('upload');
                setUploadedImage(null);
                setGeneratedImages([]);
                setSelectedImage(null);
                setFinalImage(null);
                setIsLoading(false);
                setError(null);
                setImageGenerationPrompt(''); // Reset prompt too
            }, []);

            const handleImageUpload = (base64) => {
                setUploadedImage(base64);
                setStep('menu');
            };

            const handleMenuChoice = (choice) => {
                setStep(choice);
            };

            const runImageProcessing = async (params) => {
                setIsLoading(true);
                setError(null);
                setSelectedImage(null);
                setStep('processing'); // Show loader
                try {
                    // This function now expects and handles the new object structure { base64_image, gcs_url }
                    const results = await processImageRequest(params);
                    if (!results || results.length === 0) {
                        throw new Error("The AI failed to generate images. Please try a different prompt.");
                    }

                    // --- KEY CHANGE HERE: Extract only the GCS URLs for the gallery ---
                    const gcsUrls = results.map(item => item.gcs_url);
                    setGeneratedImages(gcsUrls); // Update state with generated image URLs
                    setStep('results'); // Show image gallery

                } catch (err) {
                    console.error("Error processing image:", err);
                    setError(err.message || "An unknown error occurred.");
                    setStep('menu'); // Go back to menu if an error occurs
                } finally {
                    setIsLoading(false);
                }
            };

            const handleBgGenerate = async ({ type, shades, prompt, hex }) => {
                // If it's a prompt-based background, store the prompt
                if (type === 'prompt') {
                    setImageGenerationPrompt(prompt); // Store the prompt for background generation
                } else {
                    setImageGenerationPrompt(''); // Clear prompt if using palette
                }

                if (type === 'palette') {
                    runImageProcessing({
                        uploaded_image_base64: uploadedImage,
                        action: 'background_color',
                        background_color_hex: shades,
                        num_output_images: 5,
                    });
                } else {
                    runImageProcessing({
                        uploaded_image_base64: uploadedImage,
                        action: 'background_generated',
                        background_prompt: prompt,
                        num_output_images: 5,
                    });
                }
            };

            const handleProductGenerate = (prompt) => {
                setImageGenerationPrompt(prompt); // Store the prompt for new image generation
                runImageProcessing({
                    uploaded_image_base64: uploadedImage,
                    action: 'product_edit',
                    product_prompt: prompt,
                    num_output_images: 5,
                });
            };

            const handleConfirmSelection = () => {
                if (selectedImage) {
                    setFinalImage(selectedImage);
                    setStep('final');
                }
            };

            // MODIFIED: This function now navigates, instead of saving to device
            const handleSendToAttributeGeneration = (imageUrl) => {
                // Construct the URL for the attribute generation page
                // Assuming your attribute generation page is accessible at /admin/category-section-from-image
                // And it expects the image URL as a query parameter, e.g., ?imageUrl=...
                const attributePageUrl = `/admin/category-section-from-image?imageUrl=${encodeURIComponent(imageUrl)}`;
                
                // IMPORTANT: This 'window.location.href' will cause a full page reload.
                // In a React application using react-router-dom, you would typically use:
                // `Maps(attributePageUrl);` if `Maps` was available here.
                // Since this is a standalone HTML file, `window.location.href` is the direct approach.
                window.location.href = attributePageUrl;

                // For testing without the full app context, you could also just log or alert:
                // alert(`Simulating redirect to attribute generation with image:\n${imageUrl}`);
                // console.log(`Redirecting to: ${attributePageUrl}`);
            };


            const renderStep = () => {
                if (isLoading || step === 'processing') {
                    return (
                        <div className="container card">
                            <h2>Generating your images...</h2>
                            <p>This may take a moment. The AI is hard at work! ✨</p>
                            <div className="loader"></div>
                        </div>
                    );
                }

                if (error) {
                    return (
                        <div className="container card error-box">
                            <h2>An Error Occurred</h2>
                            <p>{error}</p>
                            <button className="button" onClick={() => { setError(null); setStep('menu'); }}>Try Again</button>
                        </div>
                    )
                }

                switch (step) {
                    case 'upload':
                        return <ImageUploader onImageUpload={handleImageUpload} />;
                    case 'menu':
                        return <MainMenu onChoice={handleMenuChoice} uploadedImage={uploadedImage} onReset={handleReset} />;
                    case 'changeBg':
                        return <BackgroundChanger onGenerate={handleBgGenerate} onBack={() => setStep('menu')} />;
                    case 'generateNew':
                        return <ProductGenerator onGenerate={handleProductGenerate} onBack={() => setStep('menu')} />;
                    case 'results':
                        return <ImageGallery
                            images={generatedImages} // This array now correctly holds GCS URLs
                            selectedImage={selectedImage}
                            onSelect={setSelectedImage}
                            onConfirm={handleConfirmSelection}
                            onReset={() => setStep('menu')}
                            inputPrompt={imageGenerationPrompt} // Pass the stored prompt
                        />;
                    case 'final':
                        return <FinalImageViewer
                            image={finalImage}
                            onSendToAttributeGeneration={handleSendToAttributeGeneration} // Pass the new handler
                            onReset={handleReset}
                        />
                    default:
                        return <ImageUploader onImageUpload={handleImageUpload} />;
                }
            };

            return (
                <div className="App">
                    <header>
                        <h1>AI Product Image Studio</h1>
                    </header>
                    <main>
                        {renderStep()}
                    </main>
                    <footer>
                        <p>Powered by React & AI</p>
                    </footer>
                </div>
            );
        }

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>